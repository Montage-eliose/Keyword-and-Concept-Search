PRECONV(1)                  General Commands Manual                 PRECONV(1)



NNAAMMEE
       preconv - convert encoding of input files to something GNU troff under-
       stands

SSYYNNOOPPSSIISS
       pprreeccoonnvv [--ddrr] [--ee _e_n_c_o_d_i_n_g] [_f_i_l_e_s _._._.]
       pprreeccoonnvv --hh | ----hheellpp
       pprreeccoonnvv --vv | ----vveerrssiioonn

       It is possible to have whitespace between the --ee  command  line  option
       and its parameter.

DDEESSCCRRIIPPTTIIOONN
       pprreeccoonnvv reads _f_i_l_e_s and converts its encoding(s) to a form GNU ttrrooffff(1)
       can process, sending the data  to  standard  output.   Currently,  this
       means ASCII characters and `\[uXXXX]' entities, where `XXXX' is a hexa-
       decimal number with four to six digits, representing  a  Unicode  input
       code.   Normally,  pprreeccoonnvv should be invoked with the --kk and --KK options
       of ggrrooffff.

OOPPTTIIOONNSS
       --dd     Emit debugging messages  to  standard  error  (mainly  the  used
              encoding).

       --DD_e_n_c_o_d_i_n_g
              Specify default encoding if everything fails (see below).

       --ee_e_n_c_o_d_i_n_g
              Specify input encoding explicitly, overriding all other methods.
              This corresponds to ggrrooffff's  --KK_e_n_c_o_d_i_n_g  option.   Without  this
              switch, pprreeccoonnvv uses the algorithm described below to select the
              input encoding.

       ----hheellpp
       --hh     Print help message.

       --rr     Do not add .lf requests.

       ----vveerrssiioonn
       --vv     Print version number.

UUSSAAGGEE
       pprreeccoonnvv tries to find the input encoding with the following algorithm.

       1.     If the input encoding has been explicitly specified with  option
              --ee, use it.

       2.     Otherwise, check whether the input starts with a _B_y_t_e _O_r_d_e_r _M_a_r_k
              (BOM, see below).  If found, use it.

       3.     Finally, check whether there is a known _c_o_d_i_n_g _t_a_g  (see  below)
              in either the first or second input line.  If found, use it.

       4.     If everything fails, use a default encoding as given with option
              --DD, by the current locale, or `latin1' if the locale is  set  to
              `C', `POSIX', or empty (in that order).

       Note that the ggrrooffff program supports a GGRROOFFFF__EENNCCOODDIINNGG environment vari-
       able which is eventually expanded to option --kk.

   BByyttee OOrrddeerr MMaarrkk
       The Unicode Standard defines character U+FEFF as the  Byte  Order  Mark
       (BOM).   On the other hand, value U+FFFE is guaranteed not be a Unicode
       character at all.  This allows to detect the byte order within the data
       stream  (either  big-endian  or  lower-endian),  and the MIME encodings
       `UTF-16' and `UTF-32' mandate that the data stream starts with  U+FEFF.
       Similarly,  the  data  stream encoded as `UTF-8' might start with a BOM
       (to ease the conversion from and to UTF-16 and UTF-32).  In all  cases,
       the  byte  order  mark is _n_o_t part of the data but part of the encoding
       protocol; in other words, pprreeccoonnvv's output doesn't contain it.

       Note that U+FEFF not at the start of the input data actually  is  emit-
       ted; it has then the meaning of a `zero width no-break space' character
       - something not needed normally in ggrrooffff.

   CCooddiinngg TTaaggss
       Editors which support more than a single character encoding  need  tags
       within the input files to mark the file's encoding.  While it is possi-
       ble to guess the right input encoding with the help of heuristic  algo-
       rithms  for  data  which  represents a greater amount of a natural lan-
       guage, it is still just a guess.   Additionally,  all  algorithms  fail
       easily for input which is either too short or doesn't represent a natu-
       ral language.

       For these reasons, pprreeccoonnvv supports the  coding  tag  convention  (with
       some  restrictions) as used by GGNNUU EEmmaaccss and XXEEmmaaccss (and probably other
       programs too).

       Coding tags in GGNNUU EEmmaaccss and XXEEmmaaccss are stored in so-called _F_i_l_e  _V_a_r_i_-
       _a_b_l_e_s.   pprreeccoonnvv recognizes the following syntax form which must be put
       into a troff comment in the first or second line.

              -*- _t_a_g_1: _v_a_l_u_e_1; _t_a_g_2: _v_a_l_u_e_2; ... -*-

       The only relevant tag for pprreeccoonnvv is `coding' which can take the values
       listed below.  Here an example line which tells EEmmaaccss to edit a file in
       troff mode, and to use latin2 as its encoding.

              .\" -*- mode: troff; coding: latin-2 -*-

       The following list gives all MIME  coding  tags  (either  lowercase  or
       uppercase) supported by pprreeccoonnvv; this list is hard-coded in the source.

              big5, cp1047, euc-jp, euc-kr, gb2312, iso-8859-1, iso-8859-2,
              iso-8859-5, iso-8859-7, iso-8859-9, iso-8859-13, iso-8859-15,
              koi8-r, us-ascii, utf-8, utf-16, utf-16be, utf-16le

       In  addition, the following hard-coded list of other tags is recognized
       which eventually map to values from the list above.

              ascii, chinese-big5, chinese-euc, chinese-iso-8bit, cn-big5,
              cn-gb, cn-gb-2312, cp878, csascii, csisolatin1,
              cyrillic-iso-8bit, cyrillic-koi8, euc-china, euc-cn, euc-japan,
              euc-japan-1990, euc-korea, greek-iso-8bit, iso-10646/utf8,
              iso-10646/utf-8, iso-latin-1, iso-latin-2, iso-latin-5,
              iso-latin-7, iso-latin-9, japanese-euc, japanese-iso-8bit, jis8,
              koi8, korean-euc, korean-iso-8bit, latin-0, latin1, latin-1,
              latin-2, latin-5, latin-7, latin-9, mule-utf-8, mule-utf-16,
              mule-utf-16be, mule-utf-16-be, mule-utf-16be-with-signature,
              mule-utf-16le, mule-utf-16-le, mule-utf-16le-with-signature,
              utf8, utf-16-be, utf-16-be-with-signature,
              utf-16be-with-signature, utf-16-le, utf-16-le-with-signature,
              utf-16le-with-signature

       Those tags are taken from GGNNUU EEmmaaccss  and  XXEEmmaaccss,  together  with  some
       aliases.   Trailing `-dos', `-unix', and `-mac' suffixes of coding tags
       (which give the end-of-line convention used in the file)  are  stripped
       off before the comparison with the above tags happens.

   IIccoonnvv IIssssuueess
       pprreeccoonnvv  by  itself only supports three encodings: latin-1, cp1047, and
       UTF-8; all other encodings are passed to the iiccoonnvv  library  functions.
       At  compile time it is searched and checked for a valid iiccoonnvv implemen-
       tation; a call to `preconv --version' shows whether iiccoonnvv is used.

BBUUGGSS
       pprreeccoonnvv doesn't support _l_o_c_a_l _v_a_r_i_a_b_l_e _l_i_s_t_s yet.  This is a  different
       syntax form to specify local variables at the end of a file.

SSEEEE AALLSSOO
       ggrrooffff(1)
       the GGNNUU EEmmaaccss and XXEEmmaaccss info pages



Groff Version 1.22.2           07 February 2013                     PRECONV(1)
