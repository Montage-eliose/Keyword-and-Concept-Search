MYISAMCHK(1)                 MySQL Database System                MYISAMCHK(1)



NNAAMMEE
       myisamchk - MyISAM table-maintenance utility

SSYYNNOOPPSSIISS
       mmyyiissaammcchhkk [[_o_p_t_i_o_n_s]] _t_b_l___n_a_m_e ......

DDEESSCCRRIIPPTTIIOONN
       The mmyyiissaammcchhkk utility gets information about your database tables or
       checks, repairs, or optimizes them.  mmyyiissaammcchhkk works with MyISAM tables
       (tables that have .MYD and .MYI files for storing data and indexes).

       You can also use the CHECK TABLE and REPAIR TABLE statements to check
       and repair MyISAM tables. See Section 13.7.2.2, "CHECK TABLE Syntax",
       and Section 13.7.2.5, "REPAIR TABLE Syntax".

       The use of mmyyiissaammcchhkk with partitioned tables is not supported.

           CCaauuttiioonn
           It is best to make a backup of a table before performing a table
           repair operation; under some circumstances the operation might
           cause data loss. Possible causes include but are not limited to
           file system errors.

       Invoke mmyyiissaammcchhkk like this:

           shell> mmyyiissaammcchhkk [[_o_p_t_i_o_n_s]] _t_b_l___n_a_m_e ......

       The _o_p_t_i_o_n_s specify what you want mmyyiissaammcchhkk to do. They are described
       in the following sections. You can also get a list of options by
       invoking mmyyiissaammcchhkk ----hheellpp.

       With no options, mmyyiissaammcchhkk simply checks your table as the default
       operation. To get more information or to tell mmyyiissaammcchhkk to take
       corrective action, specify options as described in the following
       discussion.

       _t_b_l___n_a_m_e is the database table you want to check or repair. If you run
       mmyyiissaammcchhkk somewhere other than in the database directory, you must
       specify the path to the database directory, because mmyyiissaammcchhkk has no
       idea where the database is located. In fact, mmyyiissaammcchhkk does not
       actually care whether the files you are working on are located in a
       database directory. You can copy the files that correspond to a
       database table into some other location and perform recovery operations
       on them there.

       You can name several tables on the mmyyiissaammcchhkk command line if you wish.
       You can also specify a table by naming its index file (the file with
       the .MYI suffix). This enables you to specify all tables in a directory
       by using the pattern *.MYI. For example, if you are in a database
       directory, you can check all the MyISAM tables in that directory like
       this:

           shell> mmyyiissaammcchhkk **..MMYYII

       If you are not in the database directory, you can check all the tables
       there by specifying the path to the directory:

           shell> mmyyiissaammcchhkk _/_p_a_t_h_/_t_o_/_d_a_t_a_b_a_s_e___d_i_r_/**..MMYYII

       You can even check all tables in all databases by specifying a wildcard
       with the path to the MySQL data directory:

           shell> mmyyiissaammcchhkk _/_p_a_t_h_/_t_o_/_d_a_t_a_d_i_r_/_*_/_*..MMYYII

       The recommended way to quickly check all MyISAM tables is:

           shell> mmyyiissaammcchhkk ----ssiilleenntt ----ffaasstt _/_p_a_t_h_/_t_o_/_d_a_t_a_d_i_r_/_*_/_*..MMYYII

       If you want to check all MyISAM tables and repair any that are
       corrupted, you can use the following command:

           shell> mmyyiissaammcchhkk ----ssiilleenntt ----ffoorrccee ----ffaasstt ----uuppddaattee--ssttaattee \\
                     ----kkeeyy__bbuuffffeerr__ssiizzee==6644MM ----mmyyiissaamm__ssoorrtt__bbuuffffeerr__ssiizzee==6644MM \\
                     ----rreeaadd__bbuuffffeerr__ssiizzee==11MM ----wwrriittee__bbuuffffeerr__ssiizzee==11MM \\
                     _/_p_a_t_h_/_t_o_/_d_a_t_a_d_i_r_/_*_/_*..MMYYII

       This command assumes that you have more than 64MB free. For more
       information about memory allocation with mmyyiissaammcchhkk, see the section
       called "MYISAMCHK MEMORY USAGE".

       For additional information about using mmyyiissaammcchhkk, see Section 7.6,
       "MyISAM Table Maintenance and Crash Recovery".

           IImmppoorrttaanntt
           _Y_o_u _m_u_s_t _e_n_s_u_r_e _t_h_a_t _n_o _o_t_h_e_r _p_r_o_g_r_a_m _i_s _u_s_i_n_g _t_h_e _t_a_b_l_e_s _w_h_i_l_e _y_o_u
           _a_r_e _r_u_n_n_i_n_g mmyyiissaammcchhkk. The most effective means of doing so is to
           shut down the MySQL server while running mmyyiissaammcchhkk, or to lock all
           tables that mmyyiissaammcchhkk is being used on.

           Otherwise, when you run mmyyiissaammcchhkk, it may display the following
           error message:

               warning: clients are using or haven't closed the table properly

           This means that you are trying to check a table that has been
           updated by another program (such as the mmyyssqqlldd server) that hasn't
           yet closed the file or that has died without closing the file
           properly, which can sometimes lead to the corruption of one or more
           MyISAM tables.

           If mmyyssqqlldd is running, you must force it to flush any table
           modifications that are still buffered in memory by using FLUSH
           TABLES. You should then ensure that no one is using the tables
           while you are running mmyyiissaammcchhkk

           However, the easiest way to avoid this problem is to use CHECK
           TABLE instead of mmyyiissaammcchhkk to check tables. See Section 13.7.2.2,
           "CHECK TABLE Syntax".

       mmyyiissaammcchhkk supports the following options, which can be specified on the
       command line or in the [myisamchk] group of an option file. For
       information about option files used by MySQL programs, see
       Section 4.2.6, "Using Option Files".

MMYYIISSAAMMCCHHKK GGEENNEERRAALL OOPPTTIIOONNSS
       The options described in this section can be used for any type of table
       maintenance operation performed by mmyyiissaammcchhkk. The sections following
       this one describe options that pertain only to specific operations,
       such as table checking or repairing.

       +o   ----hheellpp, --??

           Display a help message and exit. Options are grouped by type of
           operation.

       +o   ----HHEELLPP, --HH

           Display a help message and exit. Options are presented in a single
           list.

       +o   ----ddeebbuugg==_d_e_b_u_g___o_p_t_i_o_n_s, --## _d_e_b_u_g___o_p_t_i_o_n_s

           Write a debugging log. A typical _d_e_b_u_g___o_p_t_i_o_n_s string is
           d:t:o,_f_i_l_e___n_a_m_e. The default is d:t:o,/tmp/myisamchk.trace.

       +o   ----ddeeffaauullttss--eexxttrraa--ffiillee==_f_i_l_e___n_a_m_e

           Read this option file after the global option file but (on Unix)
           before the user option file. If the file does not exist or is
           otherwise inaccessible, an error occurs. Before MySQL 5.5.8,
           _f_i_l_e___n_a_m_e must be the full path name to the file. As of MySQL
           5.5.8, the name is interpreted relative to the current directory if
           given as a relative path name.

       +o   ----ddeeffaauullttss--ffiillee==_f_i_l_e___n_a_m_e

           Use only the given option file. If the file does not exist or is
           otherwise inaccessible, an error occurs. Before MySQL 5.5.8,
           _f_i_l_e___n_a_m_e must be the full path name to the file. As of MySQL
           5.5.8, the name is interpreted relative to the current directory if
           given as a relative path name.

       +o   ----ddeeffaauullttss--ggrroouupp--ssuuffffiixx==_s_t_r

           Read not only the usual option groups, but also groups with the
           usual names and a suffix of _s_t_r. For example, mmyyiissaammcchhkk normally
           reads the [myisamchk] group. If the ----ddeeffaauullttss--ggrroouupp--ssuuffffiixx==__ootthheerr
           option is given, mmyyiissaammcchhkk also reads the [myisamchk_other] group.

       +o   ----nnoo--ddeeffaauullttss

           Do not read any option files. If program startup fails due to
           reading unknown options from an option file, ----nnoo--ddeeffaauullttss can be
           used to prevent them from being read.

       +o   ----pprriinntt--ddeeffaauullttss

           Print the program name and all options that it gets from option
           files.

       +o   ----ssiilleenntt, --ss

           Silent mode. Write output only when errors occur. You can use --ss
           twice (--ssss) to make mmyyiissaammcchhkk very silent.

       +o   ----vveerrbboossee, --vv

           Verbose mode. Print more information about what the program does.
           This can be used with --dd and --ee. Use --vv multiple times (--vvvv, --vvvvvv)
           for even more output.

       +o   ----vveerrssiioonn, --VV

           Display version information and exit.

       +o   ----wwaaiitt, --ww

           Instead of terminating with an error if the table is locked, wait
           until the table is unlocked before continuing. If you are running
           mmyyssqqlldd with external locking disabled, the table can be locked only
           by another mmyyiissaammcchhkk command.

       You can also set the following variables by using ----_v_a_r___n_a_m_e==_v_a_l_u_e
       syntax:

       allbox tab(:); lB lB.  T{ Variable T}:T{ Default Value T} l l l l l l l
       l l l l l l l l l l l l l l l l l.  T{ decode_bits T}:T{ 9 T} T{
       ft_max_word_len T}:T{ version-dependent T} T{ ft_min_word_len T}:T{ 4
       T} T{ ft_stopword_file T}:T{ built-in list T} T{ key_buffer_size T}:T{
       523264 T} T{ myisam_block_size T}:T{ 1024 T} T{ myisam_sort_key_blocks
       T}:T{ 16 T} T{ read_buffer_size T}:T{ 262136 T} T{ sort_buffer_size
       T}:T{ 2097144 T} T{ sort_key_blocks T}:T{ 16 T} T{ stats_method T}:T{
       nulls_unequal T} T{ write_buffer_size T}:T{ 262136 T}


       The possible mmyyiissaammcchhkk variables and their default values can be
       examined with mmyyiissaammcchhkk ----hheellpp:

       sort_buffer_size is used when the keys are repaired by sorting keys,
       which is the normal case when you use ----rreeccoovveerr. As of MySQL 5.5.29,
       myisam_sort_buffer_size is available as an alternative name to
       sort_buffer_size.  myisam_sort_buffer_size is preferable to
       sort_buffer_size because its name corresponds to the
       myisam_sort_buffer_size server system variable that has a similar
       meaning.  sort_buffer_size should be considered deprecated.

       key_buffer_size is used when you are checking the table with
       ----eexxtteenndd--cchheecckk or when the keys are repaired by inserting keys row by
       row into the table (like when doing normal inserts). Repairing through
       the key buffer is used in the following cases:

       +o   You use ----ssaaffee--rreeccoovveerr.

       +o   The temporary files needed to sort the keys would be more than
           twice as big as when creating the key file directly. This is often
           the case when you have large key values for CHAR, VARCHAR, or TEXT
           columns, because the sort operation needs to store the complete key
           values as it proceeds. If you have lots of temporary space and you
           can force mmyyiissaammcchhkk to repair by sorting, you can use the
           ----ssoorrtt--rreeccoovveerr option.

       Repairing through the key buffer takes much less disk space than using
       sorting, but is also much slower.

       If you want a faster repair, set the key_buffer_size and
       myisam_sort_buffer_size variables to about 25% of your available
       memory. You can set both variables to large values, because only one of
       them is used at a time.

       myisam_block_size is the size used for index blocks.

       stats_method influences how NULL values are treated for index
       statistics collection when the ----aannaallyyzzee option is given. It acts like
       the myisam_stats_method system variable. For more information, see the
       description of myisam_stats_method in Section 5.1.4, "Server System
       Variables", and Section 8.3.7, "InnoDB and MyISAM Index Statistics
       Collection".

       ft_min_word_len and ft_max_word_len indicate the minimum and maximum
       word length for FULLTEXT indexes.  ft_stopword_file names the stopword
       file. These need to be set under the following circumstances.

       If you use mmyyiissaammcchhkk to perform an operation that modifies table
       indexes (such as repair or analyze), the FULLTEXT indexes are rebuilt
       using the default full-text parameter values for minimum and maximum
       word length and the stopword file unless you specify otherwise. This
       can result in queries failing.

       The problem occurs because these parameters are known only by the
       server. They are not stored in MyISAM index files. To avoid the problem
       if you have modified the minimum or maximum word length or the stopword
       file in the server, specify the same ft_min_word_len, ft_max_word_len,
       and ft_stopword_file values to mmyyiissaammcchhkk that you use for mmyyssqqlldd. For
       example, if you have set the minimum word length to 3, you can repair a
       table with mmyyiissaammcchhkk like this:

           shell> mmyyiissaammcchhkk ----rreeccoovveerr ----fftt__mmiinn__wwoorrdd__lleenn==33 _t_b_l___n_a_m_e..MMYYII

       To ensure that mmyyiissaammcchhkk and the server use the same values for
       full-text parameters, you can place each one in both the [mysqld] and
       [myisamchk] sections of an option file:

           [mysqld]
           ft_min_word_len=3
           [myisamchk]
           ft_min_word_len=3

       An alternative to using mmyyiissaammcchhkk is to use the REPAIR TABLE, ANALYZE
       TABLE, OPTIMIZE TABLE, or ALTER TABLE. These statements are performed
       by the server, which knows the proper full-text parameter values to
       use.

MMYYIISSAAMMCCHHKK CCHHEECCKK OOPPTTIIOONNSS
       mmyyiissaammcchhkk supports the following options for table checking operations:

       +o   ----cchheecckk, --cc

           Check the table for errors. This is the default operation if you
           specify no option that selects an operation type explicitly.

       +o   ----cchheecckk--oonnllyy--cchhaannggeedd, --CC

           Check only tables that have changed since the last check.

       +o   ----eexxtteenndd--cchheecckk, --ee

           Check the table very thoroughly. This is quite slow if the table
           has many indexes. This option should only be used in extreme cases.
           Normally, mmyyiissaammcchhkk or mmyyiissaammcchhkk ----mmeeddiiuumm--cchheecckk should be able to
           determine whether there are any errors in the table.

           If you are using ----eexxtteenndd--cchheecckk and have plenty of memory, setting
           the key_buffer_size variable to a large value helps the repair
           operation run faster.

           See also the description of this option under table repair options.

           For a description of the output format, see the section called
           "OBTAINING TABLE INFORMATION WITH MYISAMCHK".

       +o   ----ffaasstt, --FF

           Check only tables that haven't been closed properly.

       +o   ----ffoorrccee, --ff

           Do a repair operation automatically if mmyyiissaammcchhkk finds any errors
           in the table. The repair type is the same as that specified with
           the ----rreeccoovveerr or --rr option.

       +o   ----iinnffoorrmmaattiioonn, --ii

           Print informational statistics about the table that is checked.

       +o   ----mmeeddiiuumm--cchheecckk, --mm

           Do a check that is faster than an ----eexxtteenndd--cchheecckk operation. This
           finds only 99.99% of all errors, which should be good enough in
           most cases.

       +o   ----rreeaadd--oonnllyy, --TT

           Do not mark the table as checked. This is useful if you use
           mmyyiissaammcchhkk to check a table that is in use by some other application
           that does not use locking, such as mmyyssqqlldd when run with external
           locking disabled.

       +o   ----uuppddaattee--ssttaattee, --UU

           Store information in the .MYI file to indicate when the table was
           checked and whether the table crashed. This should be used to get
           full benefit of the ----cchheecckk--oonnllyy--cchhaannggeedd option, but you shouldn't
           use this option if the mmyyssqqlldd server is using the table and you are
           running it with external locking disabled.

MMYYIISSAAMMCCHHKK RREEPPAAIIRR OOPPTTIIOONNSS
       mmyyiissaammcchhkk supports the following options for table repair operations
       (operations performed when an option such as ----rreeccoovveerr or
       ----ssaaffee--rreeccoovveerr is given):

       +o   ----bbaacckkuupp, --BB

           Make a backup of the .MYD file as _f_i_l_e___n_a_m_e-_t_i_m_e.BAK

       +o   ----cchhaarraacctteerr--sseettss--ddiirr==_d_i_r___n_a_m_e

           The directory where character sets are installed. See Section 10.5,
           "Character Set Configuration".

       +o   ----ccoorrrreecctt--cchheecckkssuumm

           Correct the checksum information for the table.

       +o   ----ddaattaa--ffiillee--lleennggtthh==_l_e_n, --DD _l_e_n

           The maximum length of the data file (when re-creating data file
           when it is "full").

       +o   ----eexxtteenndd--cchheecckk, --ee

           Do a repair that tries to recover every possible row from the data
           file. Normally, this also finds a lot of garbage rows. Do not use
           this option unless you are desperate.

           See also the description of this option under table checking
           options.

           For a description of the output format, see the section called
           "OBTAINING TABLE INFORMATION WITH MYISAMCHK".

       +o   ----ffoorrccee, --ff

           Overwrite old intermediate files (files with names like
           _t_b_l___n_a_m_e.TMD) instead of aborting.

       +o   ----kkeeyyss--uusseedd==_v_a_l, --kk _v_a_l

           For mmyyiissaammcchhkk, the option value is a bit-value that indicates which
           indexes to update. Each binary bit of the option value corresponds
           to a table index, where the first index is bit 0. An option value
           of 0 disables updates to all indexes, which can be used to get
           faster inserts. Deactivated indexes can be reactivated by using
           mmyyiissaammcchhkk --rr.

       +o   ----nnoo--ssyymmlliinnkkss, --ll

           Do not follow symbolic links. Normally mmyyiissaammcchhkk repairs the table
           that a symlink points to. This option does not exist as of MySQL
           4.0 because versions from 4.0 on do not remove symlinks during
           repair operations.

       +o   ----mmaaxx--rreeccoorrdd--lleennggtthh==_l_e_n

           Skip rows larger than the given length if mmyyiissaammcchhkk cannot allocate
           memory to hold them.

       +o   ----ppaarraalllleell--rreeccoovveerr, --pp

           Use the same technique as --rr and --nn, but create all the keys in
           parallel, using different threads.  _T_h_i_s _i_s _b_e_t_a_-_q_u_a_l_i_t_y _c_o_d_e_. _U_s_e
           _a_t _y_o_u_r _o_w_n _r_i_s_k_!

       +o   ----qquuiicckk, --qq

           Achieve a faster repair by modifying only the index file, not the
           data file. You can specify this option twice to force mmyyiissaammcchhkk to
           modify the original data file in case of duplicate keys.

       +o   ----rreeccoovveerr, --rr

           Do a repair that can fix almost any problem except unique keys that
           are not unique (which is an extremely unlikely error with MyISAM
           tables). If you want to recover a table, this is the option to try
           first. You should try ----ssaaffee--rreeccoovveerr only if mmyyiissaammcchhkk reports that
           the table cannot be recovered using ----rreeccoovveerr. (In the unlikely
           case that ----rreeccoovveerr fails, the data file remains intact.)

           If you have lots of memory, you should increase the value of
           myisam_sort_buffer_size.

       +o   ----ssaaffee--rreeccoovveerr, --oo

           Do a repair using an old recovery method that reads through all
           rows in order and updates all index trees based on the rows found.
           This is an order of magnitude slower than ----rreeccoovveerr, but can handle
           a couple of very unlikely cases that ----rreeccoovveerr cannot. This
           recovery method also uses much less disk space than ----rreeccoovveerr.
           Normally, you should repair first using ----rreeccoovveerr, and then with
           ----ssaaffee--rreeccoovveerr only if ----rreeccoovveerr fails.

           If you have lots of memory, you should increase the value of
           key_buffer_size.

       +o   ----sseett--ccoollllaattiioonn==_n_a_m_e

           Specify the collation to use for sorting table indexes. The
           character set name is implied by the first part of the collation
           name.

       +o   ----ssoorrtt--rreeccoovveerr, --nn

           Force mmyyiissaammcchhkk to use sorting to resolve the keys even if the
           temporary files would be very large.

       +o   ----ttmmppddiirr==_d_i_r___n_a_m_e, --tt _d_i_r___n_a_m_e

           The path of the directory to be used for storing temporary files.
           If this is not set, mmyyiissaammcchhkk uses the value of the TMPDIR
           environment variable.  ----ttmmppddiirr can be set to a list of directory
           paths that are used successively in round-robin fashion for
           creating temporary files. The separator character between directory
           names is the colon (":") on Unix and the semicolon (";") on
           Windows.

       +o   ----uunnppaacckk, --uu

           Unpack a table that was packed with mmyyiissaammppaacckk.

OOTTHHEERR MMYYIISSAAMMCCHHKK OOPPTTIIOONNSS
       mmyyiissaammcchhkk supports the following options for actions other than table
       checks and repairs:

       +o   ----aannaallyyzzee, --aa

           Analyze the distribution of key values. This improves join
           performance by enabling the join optimizer to better choose the
           order in which to join the tables and which indexes it should use.
           To obtain information about the key distribution, use a mmyyiissaammcchhkk
           ----ddeessccrriippttiioonn ----vveerrbboossee _t_b_l___n_a_m_e command or the SHOW INDEX FROM
           _t_b_l___n_a_m_e statement.

       +o   ----bblloocckk--sseeaarrcchh==_o_f_f_s_e_t, --bb _o_f_f_s_e_t

           Find the record that a block at the given offset belongs to.

       +o   ----ddeessccrriippttiioonn, --dd

           Print some descriptive information about the table. Specifying the
           ----vveerrbboossee option once or twice produces additional information. See
           the section called "OBTAINING TABLE INFORMATION WITH MYISAMCHK".

       +o   ----sseett--aauuttoo--iinnccrreemmeenntt[[==_v_a_l_u_e]], --AA[[_v_a_l_u_e]]

           Force AUTO_INCREMENT numbering for new records to start at the
           given value (or higher, if there are existing records with
           AUTO_INCREMENT values this large). If _v_a_l_u_e is not specified,
           AUTO_INCREMENT numbers for new records begin with the largest value
           currently in the table, plus one.

       +o   ----ssoorrtt--iinnddeexx, --SS

           Sort the index tree blocks in high-low order. This optimizes seeks
           and makes table scans that use indexes faster.

       +o   ----ssoorrtt--rreeccoorrddss==_N, --RR _N

           Sort records according to a particular index. This makes your data
           much more localized and may speed up range-based SELECT and ORDER
           BY operations that use this index. (The first time you use this
           option to sort a table, it may be very slow.) To determine a
           table's index numbers, use SHOW INDEX, which displays a table's
           indexes in the same order that mmyyiissaammcchhkk sees them. Indexes are
           numbered beginning with 1.

           If keys are not packed (PACK_KEYS=0), they have the same length, so
           when mmyyiissaammcchhkk sorts and moves records, it just overwrites record
           offsets in the index. If keys are packed (PACK_KEYS=1), mmyyiissaammcchhkk
           must unpack key blocks first, then re-create indexes and pack the
           key blocks again. (In this case, re-creating indexes is faster than
           updating offsets for each index.)

OOBBTTAAIINNIINNGG TTAABBLLEE IINNFFOORRMMAATTIIOONN WWIITTHH MMYYIISSAAMMCCHHKK
       To obtain a description of a MyISAM table or statistics about it, use
       the commands shown here. The output from these commands is explained
       later in this section.

       +o   mmyyiissaammcchhkk --dd _t_b_l___n_a_m_e

           Runs mmyyiissaammcchhkk in "describe mode" to produce a description of your
           table. If you start the MySQL server with external locking
           disabled, mmyyiissaammcchhkk may report an error for a table that is updated
           while it runs. However, because mmyyiissaammcchhkk does not change the table
           in describe mode, there is no risk of destroying data.

       +o   mmyyiissaammcchhkk --ddvv _t_b_l___n_a_m_e

           Adding --vv runs mmyyiissaammcchhkk in verbose mode so that it produces more
           information about the table. Adding --vv a second time produces even
           more information.

       +o   mmyyiissaammcchhkk --eeiiss _t_b_l___n_a_m_e

           Shows only the most important information from a table. This
           operation is slow because it must read the entire table.

       +o   mmyyiissaammcchhkk --eeiivv _t_b_l___n_a_m_e

           This is like --eeiiss, but tells you what is being done.

       The _t_b_l___n_a_m_e argument can be either the name of a MyISAM table or the
       name of its index file, as described in mmyyiissaammcchhkk(1). Multiple _t_b_l___n_a_m_e
       arguments can be given.

       Suppose that a table named person has the following structure. (The
       MAX_ROWS table option is included so that in the example output from
       mmyyiissaammcchhkk shown later, some values are smaller and fit the output
       format more easily.)

           CREATE TABLE person
           (
             id         INT NOT NULL AUTO_INCREMENT,
             last_name  VARCHAR(20) NOT NULL,
             first_name VARCHAR(20) NOT NULL,
             birth      DATE,
             death      DATE,
             PRIMARY KEY (id),
             INDEX (last_name, first_name),
             INDEX (birth)
           ) MAX_ROWS = 1000000;

       Suppose also that the table has these data and index file sizes:

           -rw-rw----  1 mysql  mysql  9347072 Aug 19 11:47 person.MYD
           -rw-rw----  1 mysql  mysql  6066176 Aug 19 11:47 person.MYI

       Example of mmyyiissaammcchhkk --ddvvvv output:

           MyISAM file:         person
           Record format:       Packed
           Character set:       latin1_swedish_ci (8)
           File-version:        1
           Creation time:       2009-08-19 16:47:41
           Recover time:        2009-08-19 16:47:56
           Status:              checked,analyzed,optimized keys
           Auto increment key:              1  Last value:                306688
           Data records:               306688  Deleted blocks:                 0
           Datafile parts:             306688  Deleted data:                   0
           Datafile pointer (bytes):        4  Keyfile pointer (bytes):        3
           Datafile length:           9347072  Keyfile length:           6066176
           Max datafile length:    4294967294  Max keyfile length:   17179868159
           Recordlength:                   54
           table description:
           Key Start Len Index   Type                 Rec/key         Root  Blocksize
           1   2     4   unique  long                       1        99328       1024
           2   6     20  multip. varchar prefix           512      3563520       1024
               27    20          varchar                  512
           3   48    3   multip. uint24 NULL           306688      6065152       1024
           Field Start Length Nullpos Nullbit Type
           1     1     1
           2     2     4                      no zeros
           3     6     21                     varchar
           4     27    21                     varchar
           5     48    3      1       1       no zeros
           6     51    3      1       2       no zeros

       Explanations for the types of information mmyyiissaammcchhkk produces are given
       here.  "Keyfile" refers to the index file.  "Record" and "row" are
       synonymous, as are "field" and "column."

       The initial part of the table description contains these values:

       +o   MyISAM file

           Name of the MyISAM (index) file.

       +o   Record format

           The format used to store table rows. The preceding examples use
           Fixed length. Other possible values are Compressed and Packed.
           (Packed corresponds to what SHOW TABLE STATUS reports as Dynamic.)

       +o   Chararacter set

           The table default character set.

       +o   File-version

           Version of MyISAM format. Always 1.

       +o   Creation time

           When the data file was created.

       +o   Recover time

           When the index/data file was last reconstructed.

       +o   Status

           Table status flags. Possible values are crashed, open, changed,
           analyzed, optimized keys, and sorted index pages.

       +o   Auto increment key, Last value

           The key number associated the table's AUTO_INCREMENT column, and
           the most recently generated value for this column. These fields do
           not appear if there is no such column.

       +o   Data records

           The number of rows in the table.

       +o   Deleted blocks

           How many deleted blocks still have reserved space. You can optimize
           your table to minimize this space. See Section 7.6.4, "MyISAM Table
           Optimization".

       +o   Datafile parts

           For dynamic-row format, this indicates how many data blocks there
           are. For an optimized table without fragmented rows, this is the
           same as Data records.

       +o   Deleted data

           How many bytes of unreclaimed deleted data there are. You can
           optimize your table to minimize this space. See Section 7.6.4,
           "MyISAM Table Optimization".

       +o   Datafile pointer

           The size of the data file pointer, in bytes. It is usually 2, 3, 4,
           or 5 bytes. Most tables manage with 2 bytes, but this cannot be
           controlled from MySQL yet. For fixed tables, this is a row address.
           For dynamic tables, this is a byte address.

       +o   Keyfile pointer

           The size of the index file pointer, in bytes. It is usually 1, 2,
           or 3 bytes. Most tables manage with 2 bytes, but this is calculated
           automatically by MySQL. It is always a block address.

       +o   Max datafile length

           How long the table data file can become, in bytes.

       +o   Max keyfile length

           How long the table index file can become, in bytes.

       +o   Recordlength

           How much space each row takes, in bytes.

       The table description part of the output includes a list of all keys in
       the table. For each key, mmyyiissaammcchhkk displays some low-level information:

       +o   Key

           This key's number. This value is shown only for the first column of
           the key. If this value is missing, the line corresponds to the
           second or later column of a multiple-column key. For the table
           shown in the example, there are two table description lines for the
           second index. This indicates that it is a multiple-part index with
           two parts.

       +o   Start

           Where in the row this portion of the index starts.

       +o   Len

           How long this portion of the index is. For packed numbers, this
           should always be the full length of the column. For strings, it may
           be shorter than the full length of the indexed column, because you
           can index a prefix of a string column. The total length of a
           multiple-part key is the sum of the Len values for all key parts.

       +o   Index

           Whether a key value can exist multiple times in the index. Possible
           values are unique or multip.  (multiple).

       +o   Type

           What data type this portion of the index has. This is a MyISAM data
           type with the possible values packed, stripped, or empty.

       +o   Root

           Address of the root index block.

       +o   Blocksize

           The size of each index block. By default this is 1024, but the
           value may be changed at compile time when MySQL is built from
           source.

       +o   Rec/key

           This is a statistical value used by the optimizer. It tells how
           many rows there are per value for this index. A unique index always
           has a value of 1. This may be updated after a table is loaded (or
           greatly changed) with mmyyiissaammcchhkk --aa. If this is not updated at all,
           a default value of 30 is given.

       The last part of the output provides information about each column:

       +o   Field

           The column number.

       +o   Start

           The byte position of the column within table rows.

       +o   Length

           The length of the column in bytes.

       +o   Nullpos, Nullbit

           For columns that can be NULL, MyISAM stores NULL values as a flag
           in a byte. Depending on how many nullable columns there are, there
           can be one or more bytes used for this purpose. The Nullpos and
           Nullbit values, if nonempty, indicate which byte and bit contains
           that flag indicating whether the column is NULL.

           The position and number of bytes used to store NULL flags is shown
           in the line for field 1. This is why there are six Field lines for
           the person table even though it has only five columns.

       +o   Type

           The data type. The value may contain any of the following
           descriptors:

           +o   constant

               All rows have the same value.

           +o   no endspace

               Do not store endspace.

           +o   no endspace, not_always

               Do not store endspace and do not do endspace compression for
               all values.

           +o   no endspace, no empty

               Do not store endspace. Do not store empty values.

           +o   table-lookup

               The column was converted to an ENUM.

           +o   zerofill(_N)

               The most significant _N bytes in the value are always 0 and are
               not stored.

           +o   no zeros

               Do not store zeros.

           +o   always zero

               Zero values are stored using one bit.

       +o   Huff tree

           The number of the Huffman tree associated with the column.

       +o   Bits

           The number of bits used in the Huffman tree.

       The Huff tree and Bits fields are displayed if the table has been
       compressed with mmyyiissaammppaacckk. See mmyyiissaammppaacckk(1), for an example of this
       information.

       Example of mmyyiissaammcchhkk --eeiivv output:

           Checking MyISAM file: person
           Data records:  306688   Deleted blocks:       0
           - check file-size
           - check record delete-chain
           No recordlinks
           - check key delete-chain
           block_size 1024:
           - check index reference
           - check data record references index: 1
           Key:  1:  Keyblocks used:  98%  Packed:    0%  Max levels:  3
           - check data record references index: 2
           Key:  2:  Keyblocks used:  99%  Packed:   97%  Max levels:  3
           - check data record references index: 3
           Key:  3:  Keyblocks used:  98%  Packed:  -14%  Max levels:  3
           Total:    Keyblocks used:  98%  Packed:   89%
           - check records and index references
           _*_*_* _L_O_T_S _O_F _R_O_W _N_U_M_B_E_R_S _D_E_L_E_T_E_D _*_*_*
           Records:            306688  M.recordlength:       25  Packed:            83%
           Recordspace used:       97% Empty space:           2% Blocks/Record:   1.00
           Record blocks:      306688  Delete blocks:         0
           Record data:       7934464  Deleted data:          0
           Lost space:         256512  Linkdata:        1156096
           User time 43.08, System time 1.68
           Maximum resident set size 0, Integral resident set size 0
           Non-physical pagefaults 0, Physical pagefaults 0, Swaps 0
           Blocks in 0 out 7, Messages in 0 out 0, Signals 0
           Voluntary context switches 0, Involuntary context switches 0
           Maximum memory usage: 1046926 bytes (1023k)

       mmyyiissaammcchhkk --eeiivv output includes the following information:

       +o   Data records

           The number of rows in the table.

       +o   Deleted blocks

           How many deleted blocks still have reserved space. You can optimize
           your table to minimize this space. See Section 7.6.4, "MyISAM Table
           Optimization".

       +o   Key

           The key number.

       +o   Keyblocks used

           What percentage of the keyblocks are used. When a table has just
           been reorganized with mmyyiissaammcchhkk, the values are very high (very
           near theoretical maximum).

       +o   Packed

           MySQL tries to pack key values that have a common suffix. This can
           only be used for indexes on CHAR and VARCHAR columns. For long
           indexed strings that have similar leftmost parts, this can
           significantly reduce the space used. In the preceding example, the
           second key is 40 bytes long and a 97% reduction in space is
           achieved.

       +o   Max levels

           How deep the B-tree for this key is. Large tables with long key
           values get high values.

       +o   Records

           How many rows are in the table.

       +o   M.recordlength

           The average row length. This is the exact row length for tables
           with fixed-length rows, because all rows have the same length.

       +o   Packed

           MySQL strips spaces from the end of strings. The Packed value
           indicates the percentage of savings achieved by doing this.

       +o   Recordspace used

           What percentage of the data file is used.

       +o   Empty space

           What percentage of the data file is unused.

       +o   Blocks/Record

           Average number of blocks per row (that is, how many links a
           fragmented row is composed of). This is always 1.0 for fixed-format
           tables. This value should stay as close to 1.0 as possible. If it
           gets too large, you can reorganize the table. See Section 7.6.4,
           "MyISAM Table Optimization".

       +o   Recordblocks

           How many blocks (links) are used. For fixed-format tables, this is
           the same as the number of rows.

       +o   Deleteblocks

           How many blocks (links) are deleted.

       +o   Recorddata

           How many bytes in the data file are used.

       +o   Deleted data

           How many bytes in the data file are deleted (unused).

       +o   Lost space

           If a row is updated to a shorter length, some space is lost. This
           is the sum of all such losses, in bytes.

       +o   Linkdata

           When the dynamic table format is used, row fragments are linked
           with pointers (4 to 7 bytes each).  Linkdata is the sum of the
           amount of storage used by all such pointers.

MMYYIISSAAMMCCHHKK MMEEMMOORRYY UUSSAAGGEE
       Memory allocation is important when you run mmyyiissaammcchhkk.  mmyyiissaammcchhkk uses
       no more memory than its memory-related variables are set to. If you are
       going to use mmyyiissaammcchhkk on very large tables, you should first decide
       how much memory you want it to use. The default is to use only about
       3MB to perform repairs. By using larger values, you can get mmyyiissaammcchhkk
       to operate faster. For example, if you have more than 512MB RAM
       available, you could use options such as these (in addition to any
       other options you might specify):

           shell> mmyyiissaammcchhkk ----mmyyiissaamm__ssoorrtt__bbuuffffeerr__ssiizzee==225566MM \\
                      ----kkeeyy__bbuuffffeerr__ssiizzee==551122MM \\
                      ----rreeaadd__bbuuffffeerr__ssiizzee==6644MM \\
                      ----wwrriittee__bbuuffffeerr__ssiizzee==6644MM ......

       Using ----mmyyiissaamm__ssoorrtt__bbuuffffeerr__ssiizzee==1166MM is probably enough for most cases.

       Be aware that mmyyiissaammcchhkk uses temporary files in TMPDIR. If TMPDIR
       points to a memory file system, out of memory errors can easily occur.
       If this happens, run mmyyiissaammcchhkk with the ----ttmmppddiirr==_d_i_r___n_a_m_e option to
       specify a directory located on a file system that has more space.

       When performing repair operations, mmyyiissaammcchhkk also needs a lot of disk
       space:

       +o   Twice the size of the data file (the original file and a copy).
           This space is not needed if you do a repair with ----qquuiicckk; in this
           case, only the index file is re-created.  _T_h_i_s _s_p_a_c_e _m_u_s_t _b_e
           _a_v_a_i_l_a_b_l_e _o_n _t_h_e _s_a_m_e _f_i_l_e _s_y_s_t_e_m _a_s _t_h_e _o_r_i_g_i_n_a_l _d_a_t_a _f_i_l_e, as the
           copy is created in the same directory as the original.

       +o   Space for the new index file that replaces the old one. The old
           index file is truncated at the start of the repair operation, so
           you usually ignore this space. This space must be available on the
           same file system as the original data file.

       +o   When using ----rreeccoovveerr or ----ssoorrtt--rreeccoovveerr (but not when using
           ----ssaaffee--rreeccoovveerr), you need space on disk for sorting. This space is
           allocated in the temporary directory (specified by TMPDIR or
           ----ttmmppddiirr==_d_i_r___n_a_m_e). The following formula yields the amount of
           space required:

               (_l_a_r_g_e_s_t___k_e_y + _r_o_w___p_o_i_n_t_e_r___l_e_n_g_t_h) * _n_u_m_b_e_r___o_f___r_o_w_s * 2

           You can check the length of the keys and the _r_o_w___p_o_i_n_t_e_r___l_e_n_g_t_h
           with mmyyiissaammcchhkk --ddvv _t_b_l___n_a_m_e (see the section called "OBTAINING
           TABLE INFORMATION WITH MYISAMCHK"). The _r_o_w___p_o_i_n_t_e_r___l_e_n_g_t_h and
           _n_u_m_b_e_r___o_f___r_o_w_s values are the Datafile pointer and Data records
           values in the table description. To determine the _l_a_r_g_e_s_t___k_e_y
           value, check the Key lines in the table description. The Len column
           indicates the number of bytes for each key part. For a
           multiple-column index, the key size is the sum of the Len values
           for all key parts.

       If you have a problem with disk space during repair, you can try
       ----ssaaffee--rreeccoovveerr instead of ----rreeccoovveerr.

CCOOPPYYRRIIGGHHTT
       Copyright (C) 1997, 2016, Oracle and/or its affiliates. All rights
       reserved.

       This documentation is free software; you can redistribute it and/or
       modify it only under the terms of the GNU General Public License as
       published by the Free Software Foundation; version 2 of the License.

       This documentation is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
       General Public License for more details.

       You should have received a copy of the GNU General Public License along
       with the program; if not, write to the Free Software Foundation, Inc.,
       51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or see
       http://www.gnu.org/licenses/.


SSEEEE AALLSSOO
       For more information, please refer to the MySQL Reference Manual, which
       may already be installed locally and which is also available online at
       http://dev.mysql.com/doc/.

AAUUTTHHOORR
       Oracle Corporation (http://dev.mysql.com/).



MySQL 5.5                         03/01/2016                      MYISAMCHK(1)
